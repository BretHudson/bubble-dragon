<!DOCTYPE html>
<html lang="en" dir="ltr">
	<head>
		<meta charset="utf-8" />
		<title>Canvas Lord</title>
		<meta name="color-scheme" content="dark light" />
		<style media="screen">
			*,
			*::before,
			*::after {
				box-sizing: border-box;
			}

			body {
				padding: 1rem 0;
				display: flex;
				flex-direction: column;
				align-items: center;
				gap: 1rem;
			}

			.canvas-lord {
				width: 100%;
				max-width: 656px;
				margin: 0 auto;
				&:focus-within canvas {
					border-color: #bbf;
				}
			}

			.canvas-lord:has(.inspector) {
				display: grid;
				width: 100%;
			}

			.inspector {
				text-align: right;
				display: grid;
				grid-template-columns: 20ch auto;
				width: 100%;
				/* max-width: 640px; */
				margin: 0 auto;
				gap: 2px 0.5rem;
				padding: 0.5rem;
				border: 3px solid #ddd;
				border-top: 0;
			}

			canvas {
				box-sizing: content-box;
				display: block;
				width: 100%;
				max-width: 640px;
				margin: 0 auto;
				padding: 5px;
				border: 3px solid #ddd;
				image-rendering: -moz-crisp-edges;
				image-rendering: -webkit-crisp-edges;
				image-rendering: pixelated;
				image-rendering: crisp-edges;
			}
		</style>
	</head>
	<body>
		<canvas
			id="ggj-2025-game"
			width="640px"
			height="360px"
			tabindex="-1"
		></canvas>

		<script type="module">
			import {
				AssetManager,
				Game,
				Scene,
				Entity,
				Draw,
			} from './js/canvas-lord/canvas-lord.js';
			import { Vec2 } from './js/canvas-lord/util/math.js';

			const ASSETS = {
				MOLE_SKETCH_PNG: 'mole-sketch.png',
			};

			const measure_text = (ctx, text, font) => {
				ctx.font = font;
				let metrics = ctx.measureText(text);
				let t_height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
				return [metrics.width, t_height];
			};

			class FPSGraph extends Entity {
				constructor(x, y, graphSize) {
					super(x, y);
					this.graphSize = graphSize;
				}

				update(input) {
					//
				}

				render(ctx) {
					const game = this.scene.engine;
					let { width, height } = game.canvas;
					const frame_arr = game.recentFrames;

					let min_val = Number.MAX_VALUE;
					let max_val = Number.MIN_VALUE;
					let sum_val = 0;

					for (let frame of frame_arr) {
						max_val = Math.max(max_val, frame);
						min_val = Math.min(min_val, frame);
						sum_val += frame;
					}
					let avg_val = sum_val / frame_arr.length;
					let range = max_val - min_val;

					let graph_size = 65;
					let pad_size = 2;
					let graph_pos = {x: this.x, y: this.y};
					let graph_x_max = this.graphSize - pad_size;
					let graph_y_max = this.graphSize - pad_size;
					Draw.rect(ctx, {type: 'fill', color: '#A0A0A0'}, graph_pos.x, graph_pos.y, this.graphSize, this.graphSize);

					let avg_fps_text = 'avg: ' + avg_val.toFixed(2) + ' ms';
					let font = '8px monospace';
					let [tw, th] = measure_text(ctx, avg_fps_text, font);
					let line_y = graph_pos.y + this.graphSize + pad_size;
					Draw.text(ctx,
						{type: 'fill', font: font, color: '#000000'},
						graph_pos.x + this.graphSize - tw - pad_size,
						line_y + th,
						avg_fps_text
					); line_y += th + pad_size;

					let min_fps_text = 'min: ' + min_val.toFixed(2) + ' ms';
					[tw, th] = measure_text(ctx, min_fps_text, font);
					Draw.text(ctx,
						{type: 'fill', font: font, color: '#000000'},
						graph_pos.x + this.graphSize - tw - pad_size,
						line_y + th,
						min_fps_text
					); line_y += th + pad_size;

					let max_fps_text = 'max: ' + max_val.toFixed(2) + ' ms';
					[tw, th] = measure_text(ctx, max_fps_text, font);
					Draw.text(ctx,
						{type: 'fill', font: font, color: '#000000'},
						graph_pos.x + this.graphSize - tw - pad_size,
						line_y + th,
						max_fps_text
					);
					for (let i = 1; i < frame_arr.length; i++) {
						const get_pos = (frame) => {
							let x_off = i * (graph_x_max / frame_arr.length);
							let y_off = (frame - min_val) * (graph_y_max / range);

							let px = graph_pos.x + (pad_size / 2) + x_off;
							let py = graph_pos.y + this.graphSize - y_off - (pad_size / 2);
							return [px, py];
						};
						let [lx, ly] = get_pos(frame_arr[i-1]);
						let [cx, cy] = get_pos(frame_arr[i]);
						Draw.line(ctx, {}, lx, ly, cx, cy);
					}
				}
			}

			let game;
			const assetManager = new AssetManager('./img/');
			assetManager.addImage(ASSETS.MOLE_SKETCH_PNG);
			assetManager.onLoad(() => {
				if (game) return;

				game = new Game('ggj-2025-game', {
					fps: 60,
					gameLoopSettings: {
						updateMode: 'always', // or set it to 'focus'
						renderMode: 'onUpdate',
					},
				});
				game.assetManager = assetManager;
				game.backgroundColor = '#6c6d71';

				const scene = new Scene(game);

				const canvasSize = new Vec2(
					game.canvas.width,
					game.canvas.height,
				);
				const canvasCenter = canvasSize.scale(0.5);

				const test = new FPSGraph(game.width - 65, 0, 65);
				scene.addEntity(test);
				scene.addRenderable(test);

				game.pushScene(scene);

				game.render();
			});
			assetManager.loadAssets();
		</script>
	</body>
</html>
